#' Calculate average marginal predictions
#'
#' @param marginal_preds Object of class \code{marginalPreds} generated by \code{marginal_predictions}.
#' @param target_vars Character string of targeted predictor variable names from which to derive predictions.
#' @param ext_vars Character string of external predictor variable names across which equal weighting will be applied.
#' @param wt Character string indicating the type of weighting to be applied to the calculation of mean predictions. See details below.
#' @param interval Numeric values specifying the central proportion of predictions to report. Default is 90%
#'
#' @author Jason Grafmiller
#'
#' @details Add details here
#'
#' @return A \code{data.frame} including all combinations of values in \code{target_vars}.
#' \describe{
#' \item{\code{mean}}{The mean of model predictions weighted by the marginal distributions across all predictors other than \code{target_vars} and \code{ext_vars}.}
#' \item{\code{lower}}{The lower percentile of model predictions set by \code{interval}.}
#' \item{\code{upper}}{The upper percentile of model predictions set by \code{interval}.}
#' }
#'
#' @references Add references here
#' @export
#'
#' @examples
#' \dontrun{}
marginal_avg <- function(marginal_preds, target_vars, ext_vars = NULL,
                         wt = c("iso", "joint", "all"),
                         interval = c(.05, .95),
                         verbose = TRUE){
  require(data.table)

  if(class(marginal_preds) != "marginalPreds") stop(paste(marginal_preds, 'is not of class "marginalPreds"'))

  wt <- match.arg(wt)
  n.breaks <- marginal_preds$n.breaks
  mar_table <- marginal_preds$predictions
  data <- marginal_preds$data
  pred_outcome <- marginal_preds$predicted.outcome

  # Convert data and tables to data.table objects for faster processing
  if(!is.data.table(mar_table)) mar_table <- as.data.table(mar_table)
  if(!is.data.table(data)) data_dt <- as.data.table(data)

  # Get vector of all predictor names
  full_vars <- marginal_preds$variable_names

  # Create version of the data based on the bins ------
  # Get peripheral predictor variables
  peripheral_vars <- full_vars[!(full_vars %in% target_vars)]

  # exclude any external variables
  if(!is.null(ext_vars)) peripheral_vars <- peripheral_vars[!(peripheral_vars %in% ext_vars)]

  num_vars <- peripheral_vars[sapply(data[, peripheral_vars], is.numeric)]
    #
  if(length(num_vars) > 0) {
    # Convert numeric columns to factors for merging
    mar_table[ , (num_vars) := lapply(.SD, as.factor), .SDcols = num_vars]
    data_dt[ , (num_vars) := lapply(.SD, as.factor), .SDcols = num_vars]
    binned_d <- data_dt
    binned_d[ , (num_vars) := lapply(.SD, function(x) cut2(x, n.breaks)), .SDcols = num_vars]
  } else {
    binned_d <- data_dt
  }
  #
  # # Create dataframe of weights
  # # TO DO: adjust for isolated weights
  if(wt == "joint"){
    count_dt <- ftable(binned_d[, ..peripheral_vars]) |>
      as.data.frame() |>
      as.data.table()
    prop_f <- function(x) x/nrow(data)
    count_dt[, wt := prop_f(Freq)]
    names(count_dt)[1:length(peripheral_vars)] <- peripheral_vars

    # merge data_dt with the the weighting data.table

    mar_table <- merge(mar_table, count_dt, by = peripheral_vars, all.x = TRUE)

  } else if (wt == "iso"){
    # stop("I'm not sure what to do here...")
    # wt_list <- lapply(peripheral_vars, function(x){
    for(i in seq_along(peripheral_vars)){
      p <- peripheral_vars[i]
      df <- as.data.frame(table(binned_d[, get(p)]))
      df$prop <- df$Freq/sum(df$Freq)
      names(df)[1] <- p
      names(df)[2] <- paste0("freq_", p)
      names(df)[3] <- paste0("prop_", p)
      df[, 1] <- as.factor(df[, 1])

      mar_table <- merge(mar_table, df, by = p, all.x = TRUE)
      # return(df)
    }

    mar_table$wt <- apply(
      mar_table[, names(mar_table)[startsWith(names(mar_table), "prop_")], with=FALSE],
      1,
      prod
      )

    # )
    # for(p in seq_along(wt_list)){
    #   mar_table <- merge(mar_table, wt_list[[1]], by = )
    # }
  } else if (wt == "all"){
    count_dt <- ftable(binned_d[, ..full_vars]) |>
      as.data.frame() |>
      as.data.table()
    prop_f <- function(x) x/nrow(data)
    count_dt[, wt := prop_f(Freq)]
    names(count_dt)[1:length(full_vars)] <- full_vars

    # merge data_dt with the the weighting data.table

    mar_table <- merge(mar_table, count_dt, by = full_vars, all.x = TRUE)
  }

  # get the averages
  mar_avg_df <- mar_table[, .(mean_prob = weighted.mean(pred_prob, wt)),
                       by = c(target_vars, "tree")][, .(mean = mean(mean_prob),
                                                 lower = quantile(mean_prob, interval[1]),
                                                 upper = quantile(mean_prob, interval[2])),
                                             by = target_vars] |>
    as.data.frame() # convert back to data.frame

  names(mar_avg_df)[names(mar_avg_df) == "mean"] <- paste("mean_prob", pred_outcome, sep = "_")

  num_tar_vars <- target_vars[target_vars %in% target_vars[sapply(data[, target_vars], is.numeric)]]

  if(length(num_tar_vars) > 0) mar_avg_df[num_tar_vars] <- lapply(mar_avg_df[num_tar_vars], function(x) as.numeric(as.character(x))) # convert back to numeric

  return(mar_avg_df)

}
