#' Calculate weighted average contrasts between random forest predictions for target predictor values
#'
#' @param marginal_preds Object of class \code{treePredictions} generated by \code{tree_predictions}.
#' @param target.vars Character string of targeted predictor variable names from which to derive predictions.
#' @param by Character string of secondary variables over which the target contrasts should be averaged.
#' @param equal.wt Character string of external predictor variable names across which equal weighting will be applied.
#' @param wt Character string indicating the type of weighting to be applied to the calculation of mean predictions. See details below.
#' @param interval Numeric values specifying the central proportion of predictions to report. Default is 90%
#' @param verbose Logical. Should extra information be printed?
#'
#' @author Jason Grafmiller
#'
#' @details This is a wrapper function which takes the output of \code{predicted_contrasts} and calculated weighted average contrasts for secondary predictor levels.
#'
#' @references
#'
#' SÃ¶nning, Lukas & Jason Grafmiller. 2022. Seeing the wood for the trees: Predictive margins for random forests. Preprint. \emph{PsyArXiv}. \url{https://doi.org/10.31234/osf.io/jr8yk}.
#' @return a \code{data.frame}
#' @export
#'
#' @examples
#' \dontrun{}
avg_contrasts <- function(marginal_preds, target.vars, by = NULL, equal.wt = NULL,
                            wt = c("iso", "joint", "all"),
                            interval = c(.05, .95),
                            verbose = TRUE){
  require(data.table)

  if(class(marginal_preds) != "treePredictions") stop(paste(marginal_preds, 'is not of class "treePredictions"'))

  wt <- match.arg(wt)
  n.breaks <- marginal_preds$n.breaks
  mar_table <- marginal_preds$predictions
  data <- marginal_preds$data
  pred_outcome <- paste0(marginal_preds$predicted.outcome, "_pred")

  # Convert data and tables to data.table objects for faster processing
  if(!is.data.table(mar_table)) mar_table <- as.data.table(mar_table)
  if(!is.data.table(data)) data_dt <- as.data.table(data)

  # Get vector of all predictor names
  full_vars <- marginal_preds$variable_names

  # Create version of the data based on the bins ------
  # Get peripheral predictor variables
  peripheral_vars <- full_vars[!(full_vars %in% target.vars)]

  # Get levels of the target variable
  levs <- sort(as.character(unique(mar_table[, get(target.vars)])))

  # exclude any external variables
  if(!is.null(equal.wt)) peripheral_vars <- peripheral_vars[!(peripheral_vars %in% equal.wt)]

  contrast_df <- predicted_contrasts(marginal_preds, target.vars, interval, verbose = verbose)

  if(is.null(by)){
    message("No secondary variable(s) provided. Set `by = ` to calculate weighted averages by secondary variables.")
    return(contrast_df)
  } else {

    contrast_dt <- as.data.table(contrast_df)

    if(verbose){
      if(wt == "iso") {
        message("\nWeightings of feature combinations are based on their expected distribution derived from their independent marginal distributions in the dataset.")
      } else if(wt == "joint"){
        message("\nWeightings of feature combinations are based on their joint distribution observed in the dataset.")
      }
    }

    num_vars <- peripheral_vars[sapply(data[, peripheral_vars], is.numeric)]

    if(length(num_vars) > 0) {
      # Convert numeric columns to factors for merging
      mar_table[ , (num_vars) := lapply(.SD, as.factor), .SDcols = num_vars]
      data_dt[ , (num_vars) := lapply(.SD, as.factor), .SDcols = num_vars]
      binned_d <- data_dt
      binned_d[ , (num_vars) := lapply(.SD, function(x) cut2(x, n.breaks)), .SDcols = num_vars]
    } else {
      binned_d <- data_dt
    }

    # Create dataframe of weights
    if(wt == "joint"){
      count_dt <- ftable(binned_d[, ..peripheral_vars]) |>
        as.data.frame() |>
        as.data.table()
      prop_f <- function(x) x/nrow(data)
      count_dt[, wt := prop_f(Freq)]
      names(count_dt)[1:length(peripheral_vars)] <- peripheral_vars

      # merge data_dt with the the weighting data.table

      mar_table <- merge(mar_table, count_dt, by = peripheral_vars, all.x = TRUE)

    } else if (wt == "iso"){
      # stop("I'm not sure what to do here...")
      # wt_list <- lapply(peripheral_vars, function(x){
      for(i in seq_along(peripheral_vars)){
        p <- peripheral_vars[i]
        df <- as.data.frame(table(binned_d[, get(p)]))
        df$prop <- df$Freq/sum(df$Freq)
        names(df)[1] <- p
        names(df)[2] <- paste0("freq_", p)
        names(df)[3] <- paste0("prop_", p)
        df[, 1] <- as.factor(df[, 1])

        mar_table <- merge(mar_table, df, by = p, all.x = TRUE)
        # return(df)
      }

      mar_table$wt <- apply(
        mar_table[, names(mar_table)[startsWith(names(mar_table), "prop_")], with=FALSE],
        1,
        prod
      )

      # )
      # for(p in seq_along(wt_list)){
      #   mar_table <- merge(mar_table, wt_list[[1]], by = )
      # }
    } else if (wt == "all"){
      count_dt <- ftable(binned_d[, ..full_vars]) |>
        as.data.frame() |>
        as.data.table()
      prop_f <- function(x) x/nrow(data)
      count_dt[, wt := prop_f(Freq)]
      names(count_dt)[1:length(full_vars)] <- full_vars

      # merge data_dt with the the weighting data.table

      mar_table <- merge(mar_table, count_dt, by = full_vars, all.x = TRUE)
    }

    # merge the contrast table and the table with weights
    cols <- c(peripheral_vars, "wt")
    contrast_wt_dt <- merge(contrast_dt, unique(mar_table[, ..cols]), by = peripheral_vars, all.x = TRUE)

    # get the averages
    contrast_col <- names(contrast_wt_dt)[grepl("contrast", names(contrast_wt_dt))]
    contrast_avg_df <- contrast_wt_dt[, .(mean_pred = weighted.mean(get(contrast_col), wt),
                                          lower = quantile(get(contrast_col), interval[1]),
                                          upper = quantile(get(contrast_col), interval[2])), by = by] |>
      as.data.frame() # convert back to data.frame

    names(contrast_avg_df)[names(contrast_avg_df) == "mean_pred"] <- paste("mean", levs[2], levs[1], "contrast", sep = "_")

    num_tar_vars <- target.vars[target.vars %in% target.vars[sapply(data[, target.vars], is.numeric)]]

    if(length(num_tar_vars) > 0) contrast_avg_df[num_tar_vars] <- lapply(contrast_avg_df[num_tar_vars], function(x) as.numeric(as.character(x))) # convert back to numeric

    return(contrast_avg_df)
  }
}
